# Dockit 사용자 메뉴얼

이 문서는 Dockit의 자세한 사용 방법을 설명합니다.

## 목차

1. [소개](#소개)
2. [설치](#설치)
3. [새로운 주요 기능](#새로운-주요-기능)
    - [실시간 Docker 상태 동기화](#실시간-docker-상태-동기화)
    - [이미지 재사용 기능](#이미지-재사용-기능)
    - [확장된 프로젝트 상태 시스템](#확장된-프로젝트-상태-시스템)
4. [명령어](#명령어)
    - [init](#init---초기화)
    - [start](#start---컨테이너-시작)
    - [build](#build---Docker-이미지-빌드)
    - [up](#up---백그라운드에서-컨테이너-시작)
    - [stop](#stop---컨테이너-정지)
    - [down](#down---컨테이너-제거)
    - [connect](#connect---컨테이너-접속)
    - [status](#status---상태-확인)
    - [list](#list---프로젝트-목록)
    - [ls](#ls---빠른-프로젝트-목록)
    - [image](#image---이미지-관리)
    - [migrate](#migrate---버전-업그레이드)
    - [setup](#setup---전체-환경-설정)
    - [run](#run---자동-실행)
    - [ps](#ps---컨테이너-목록)
    - [help](#help---도움말)
5. [설정 파일](#설정-파일)
6. [문제 해결](#문제-해결)

## 소개

Dockit은 Docker를 사용하여 개발 환경을 빠르게 설정하고 관리하기 위한 모듈식 쉘 스크립트 도구입니다. 이 도구는 Docker 컨테이너를 통해 일관된 개발 환경을 제공하며, 다양한 운영체제에서 동일한 환경을 구성할 수 있도록 도와줍니다.

Dockit의 주요 목표는 다음과 같습니다:
- 개발 환경 설정의 복잡성 감소
- 일관된 개발 환경 제공
- 개발 설정의 이식성 향상
- 팀 작업을 위한 표준화된 환경 구성

## 설치

### 요구 사항

- Docker가 설치되어 있어야 합니다.
- Bash 쉘 환경이 필요합니다.

### 설치 방법

Dockit을 설치하려면 다음 명령어를 실행하세요:

```bash
# 저장소 복제
git clone https://github.com/namugach/dockit.git
cd dockit

# 설치 스크립트 실행
./bin/install.sh
```

이 명령어는 Dockit을 시스템에 설치하고 쉘 환경에 필요한 경로를 추가합니다.
설치 후에는 어떤 디렉토리에서든 `dockit` 명령을 사용할 수 있습니다.

### 제거하기

Dockit을 시스템에서 제거하려면:

```bash
./bin/uninstall.sh
```

## 새로운 주요 기능

### 실시간 Docker 상태 동기화

Dockit v1.3.0부터 `dockit list` 명령어는 실시간으로 실제 Docker 상태와 레지스트리 정보를 동기화합니다.

#### 주요 특징:
- **자동 상태 감지**: `dockit list` 실행 시 각 프로젝트의 실제 Docker 이미지 및 컨테이너 상태를 확인
- **외부 변경 감지**: Docker 명령어로 직접 변경한 이미지/컨테이너 상태도 자동으로 반영
- **수동 error 상태 보존**: 빌드 실패로 설정된 `error` 상태는 자동으로 변경되지 않음
- **성능 최적화**: Docker가 없거나 레지스트리 파일이 없는 경우 안전하게 건너뜀

#### 동작 예시:
```bash
# 외부에서 이미지 삭제
docker image rm my-project-image

# dockit list 실행 시 자동으로 상태가 ready → none으로 변경됨
dockit list
```

### 이미지 재사용 기능

다른 프로젝트에서 이미 빌드한 이미지를 재사용하여 개발 효율성을 높이고 시스템 자원을 절약할 수 있습니다.

#### 사용 방법:
```bash
dockit init
# 선택 옵션에서 'l - 이미지 재사용' 선택
# 재사용할 프로젝트의 절대 경로 입력 (예: /home/user/project)
```

#### 주요 특징:
- **경로 기반 이미지 공유**: 절대 경로를 입력하면 해당 프로젝트의 이미지명을 자동으로 생성하여 재사용
- **이미지 존재 검증**: 입력한 경로의 이미지가 실제로 존재하는지 자동 확인
- **안전한 재사용**: 존재하지 않는 이미지의 경우 재시도 또는 취소 옵션 제공
- **자원 효율성**: 동일한 베이스 환경을 여러 프로젝트에서 공유하여 디스크 공간 절약

#### 활용 시나리오:
- 동일한 개발 환경을 여러 프로젝트에서 사용
- 팀 내에서 표준화된 개발 이미지 공유
- 베이스 이미지 빌드 시간 단축

### 확장된 프로젝트 상태 시스템

프로젝트의 전체 라이프사이클을 더 정확하게 추적할 수 있는 새로운 상태들이 추가되었습니다.

#### 새로운 상태들:
- **`none`**: 프로젝트 초기화 후 아직 이미지가 빌드되지 않은 상태
- **`ready`**: 이미지 빌드가 완료되어 컨테이너 실행 준비가 완료된 상태  
- **`error`**: 이미지 빌드 실패 또는 기타 오류가 발생한 상태

#### 기존 상태들:
- **`running`**: 컨테이너가 실행 중인 상태
- **`stopped`**: 컨테이너가 정지된 상태
- **`down`**: 컨테이너가 제거된 상태 (이미지는 존재할 수 있음)

#### 상태 전환 흐름:
```
init → none → build → ready → up → running
                ↓              ↓
              error          stopped → down
```

#### 상태별 표시 색상:
- `none`: 파란색 (blue)
- `ready`: 청록색 (cyan)  
- `error`: 빨간색 (red)
- `running`: 초록색 (green)
- `stopped`: 노란색 (yellow)
- `down`: 회색 (gray)

## 명령어

Dockit은 다음과 같은 명령어를 제공합니다:

### init - 초기화

Docker 개발 환경을 초기화하고 설정합니다.

```bash
dockit init
```

이 명령어는 다음 작업을 수행합니다:
- `.dockit_project` 디렉토리 생성
- 사용자 설정 정보 수집
- Docker 이미지 빌드 또는 기존 이미지 재사용
- docker-compose.yml 파일 생성

#### 디렉터리 이름 검증 및 자동 변경:

초기화 시작 전에 현재 디렉터리 이름이 Docker 이미지 이름 규칙에 적합한지 자동으로 검증합니다.

**주요 기능:**
- **대문자 감지**: 디렉터리 이름에 대문자가 포함되어 있는지 자동 확인
- **자동 변환**: 카멜케이스를 스네이크케이스로 변환 (예: `MyProject` → `my_project`)
- **안전한 변경**: 대상 디렉터리 존재 여부 확인 및 충돌 방지
- **자동 재시작**: 디렉터리 변경 후 새 위치에서 초기화 자동 재시작

**동작 예시:**
```bash
# 현재 디렉터리: /home/user/MyProject
dockit init

# 경고 메시지 표시:
# "현재 디렉터리 이름에 대문자가 포함되어 있습니다."
# "Docker 이미지 이름 규칙상 소문자만 허용됩니다."
# 
# 현재: /home/user/MyProject
# 제안: /home/user/my_project
# 
# 디렉터리 이름을 변경하시겠습니까? [Y/n]: Y

# 자동 변경 후 새 디렉터리에서 초기화 재시작
```

**사용자 선택사항:**
- **Y (기본값)**: 제안된 이름으로 디렉터리 변경 후 초기화 계속
- **n**: 변경 취소, 현재 이름 그대로 사용하거나 수동 변경 권장

#### 초기화 옵션:

초기화 과정에서는 다음 두 가지 방식 중 선택할 수 있습니다:

**1. 새로운 이미지 빌드** (기본 옵션):
- 사용자 이름, UID/GID, 비밀번호, 작업 디렉토리 등을 설정
- 베이스 이미지 선택 (Ubuntu, CentOS, Alpine 등)
- 새로운 Docker 이미지를 빌드하여 프로젝트별 맞춤 환경 구성

**2. 이미지 재사용** (`l - 이미지 재사용` 옵션):
- 다른 프로젝트에서 이미 빌드한 이미지를 재사용
- 재사용할 프로젝트의 **절대 경로**를 입력 (예: `/home/user/my-base-project`)
- 이미지 존재 확인 후 재사용 설정 완료

#### 이미지 재사용 워크플로우:
```bash
dockit init
# 'l - 이미지 재사용' 선택
# 절대 경로 입력: /home/hgs/my-base-project
# 이미지 존재 확인 후 재사용 설정 완료
```

#### 재사용 시 주의사항:
- 입력한 경로의 `.dockit_project/.env` 파일에서 이미지 이름을 추출
- 해당 이미지가 실제로 Docker에 존재하는지 검증
- 존재하지 않는 이미지의 경우 재시도 또는 새로운 빌드 옵션 제공

초기화 과정에서는 다음 정보를 설정할 수 있습니다:
- 사용자 이름
- UID/GID
- 비밀번호
- 작업 디렉토리
- 이미지 이름 (새 빌드 시) 또는 재사용할 이미지 경로
- 컨테이너 이름

### Start 명령어

`start` 명령어는 컨테이너를 시작하는 데 사용됩니다. 컨테이너가 존재하지 않는 경우 자동으로 생성하고 시작할 수 있는 옵션을 제공합니다.

사용법:
```bash
dockit start [옵션]
```

옵션:
- (인자 없음): 사용 가능한 컨테이너 목록 표시
- `number`: 목록에서 지정된 번호의 컨테이너 시작
- `"this"`: 현재 프로젝트 디렉토리의 컨테이너 시작
- `"all"`: 모든 dockit 컨테이너 시작

**자동 생성 기능:**
컨테이너가 존재하지 않는 경우 다음과 같이 묻습니다:
- "컨테이너가 존재하지 않습니다. 컨테이너를 생성하고 시작하시겠습니까? (Y/n)"
- 'Y'를 선택하면 자동으로 `dockit up`을 실행하여 컨테이너를 생성하고 시작합니다
- 'n'을 선택하면 작업이 취소됩니다

예제:
```bash
dockit start           # 컨테이너 목록 표시
dockit start 1         # 1번 컨테이너 시작 (없으면 생성)
dockit start 1 2 3     # 1, 2, 3번 컨테이너 시작
dockit start this      # 현재 프로젝트 컨테이너 시작 (없으면 생성)
dockit start all       # 모든 dockit 컨테이너 시작
```

### build - Docker 이미지 빌드

개발 환경용 Docker 이미지를 빌드합니다.

```bash
dockit build [옵션]
```

#### 옵션:
- (인자 없음): 현재 프로젝트의 이미지 빌드
- `number`: 목록에서 지정된 번호의 프로젝트 빌드
- `"this"`: 현재 프로젝트 디렉토리의 이미지 빌드
- `"all"`: 모든 dockit 프로젝트를 병렬로 빌드
- `--no-cache`: Docker 캐시를 사용하지 않고 이미지를 강제로 리빌드

#### 사용 예:
```bash
dockit build              # 현재 프로젝트 빌드 (캐시 사용)
dockit build 1            # 1번 프로젝트 빌드
dockit build this         # 현재 프로젝트 빌드
dockit build all          # 모든 프로젝트 병렬 빌드
dockit build --no-cache   # 현재 프로젝트 캐시 없이 강제 리빌드
dockit build 1 --no-cache # 1번 프로젝트 캐시 없이 빌드
```

#### 주요 기능:
- **병렬 빌드**: `all` 옵션 사용 시 여러 프로젝트를 동시에 빌드하여 시간 절약
- **개별 빌드 실패 격리**: 한 프로젝트 빌드 실패가 다른 프로젝트에 영향을 주지 않음
- **자동 상태 관리**: 빌드 성공 시 `ready` 상태, 실패 시 `error` 상태로 자동 전환
- **컨테이너 정리**: 빌드 시작 전 기존 컨테이너 자동 정지 및 제거

이 명령어는 다음 작업을 수행합니다:
- `.dockit_project/Dockerfile`을 사용하여 이미지 빌드
- 사용자가 수정한 Dockerfile 내용이 빌드에 반영됨
- `--no-cache` 옵션으로 Docker 캐싱 문제 해결
- UID 충돌 감지 및 자동 사용자 처리 수행

#### 사용자 Dockerfile 커스터마이징:
`dockit init` 후 생성되는 `.dockit_project/Dockerfile`을 직접 수정할 수 있습니다:
- 추가 패키지 설치
- 환경 변수 설정
- 커스텀 설정 추가
- 수정 후 `dockit build`로 변경사항 반영

#### UID 충돌 자동 처리:
베이스 이미지에 이미 동일한 UID를 가진 사용자가 존재하는 경우:
- 기존 사용자를 자동으로 감지
- 해당 사용자에게 설정된 비밀번호 적용
- sudo 권한 자동 부여
- 파일 권한 문제 없이 원활한 작업 환경 제공

### Up 명령어

컨테이너를 접속 프롬프트 없이 백그라운드에서 시작합니다.

사용법:
```bash
dockit up [옵션]
```

옵션:
- (인자 없음): 사용 가능한 컨테이너 목록 표시
- `number`: 목록에서 지정된 번호의 컨테이너 시작
- `"this"`: 현재 프로젝트 디렉토리의 컨테이너 시작
- `"all"`: 모든 dockit 컨테이너 시작

이 명령어는 다음 작업을 수행합니다:
- Docker Compose를 사용하여 분리 모드(detached mode)로 컨테이너 시작
- 컨테이너 접속 여부를 묻지 않음
- 컨테이너 상태 정보 표시
- 자동화 스크립트나 즉시 접속이 필요 없을 때 유용함

예제:
```bash
dockit up             # 컨테이너 목록 표시
dockit up 1           # 1번 컨테이너 시작
dockit up 1 2 3       # 1, 2, 3번 컨테이너 시작
dockit up this        # 현재 프로젝트 컨테이너 시작
dockit up all         # 모든 dockit 컨테이너 시작
```

### Stop 명령어

`stop` 명령어는 실행 중인 컨테이너를 중지하는 데 사용됩니다. 이 명령어는 컨테이너 상태를 유지합니다.

사용법:
```bash
dockit stop [옵션]
```

옵션:
- (인자 없음): 사용 가능한 컨테이너 목록 표시
- `number`: 목록에서 지정된 번호의 컨테이너 중지
- `"this"`: 현재 프로젝트 디렉토리의 컨테이너 중지
- `"all"`: 모든 dockit 컨테이너 중지

예제:
```bash
dockit stop           # 컨테이너 목록 표시
dockit stop 1         # 1번 컨테이너 중지
dockit stop 1 2 3     # 1, 2, 3번 컨테이너 중지
dockit stop this      # 현재 프로젝트 컨테이너 중지
dockit stop all       # 모든 dockit 컨테이너 중지
```

### Down 명령어

컨테이너를 완전히 제거합니다.

사용법:
```bash
dockit down [옵션]
```

옵션:
- (인자 없음): 사용 가능한 컨테이너 목록 표시
- `number`: 목록에서 지정된 번호의 컨테이너 제거
- `"this"`: 현재 프로젝트 디렉토리의 컨테이너 제거
- `"all"`: 모든 dockit 컨테이너 제거

이 명령어는 컨테이너를 중지하고 제거합니다. 컨테이너 내부에 저장된 모든 데이터가 삭제되므로 주의해서 사용해야 합니다.

예제:
```bash
dockit down           # 컨테이너 목록 표시
dockit down 1         # 1번 컨테이너 제거
dockit down 1 2 3     # 1, 2, 3번 컨테이너 제거
dockit down this      # 현재 프로젝트 컨테이너 제거
dockit down all       # 모든 dockit 컨테이너 제거
```

### Connect 명령어

자동 생성 및 자동 시작 기능을 갖춘 컨테이너 접속 명령어입니다.

사용법:
```bash
dockit connect [옵션]
```

옵션:
- (인자 없음): 사용법 정보 표시
- `number`: 목록에서 지정된 번호의 컨테이너에 접속
- `"this"`: 현재 프로젝트 디렉토리의 컨테이너에 접속

**자동 생성 및 자동 시작 기능:**

1. **컨테이너가 존재하지 않는 경우:**
   - "컨테이너가 존재하지 않습니다. 컨테이너를 생성하고 시작한 후 접속하시겠습니까? (Y/n)"
   - 'Y'를 선택하면 자동으로 `dockit up`을 실행하여 컨테이너를 생성하고 시작한 후 접속합니다
   - 'n'을 선택하면 작업이 취소됩니다

2. **컨테이너가 중지된 경우:**
   - "컨테이너가 중지되어 있습니다. 컨테이너를 시작한 후 접속하시겠습니까? (Y/n)"
   - 'Y'를 선택하면 컨테이너를 시작한 후 접속합니다
   - 'n'을 선택하면 작업이 취소됩니다

3. **컨테이너가 실행 중인 경우:**
   - 즉시 컨테이너에 접속합니다

예제:
```bash
dockit connect         # 사용법 정보 표시
dockit connect 1       # 1번 컨테이너에 접속 (필요시 생성/시작)
dockit connect this    # 현재 프로젝트 컨테이너에 접속 (필요시 생성/시작)
```

이 명령어는 컨테이너의 현재 상태에 관계없이 단일 명령으로 어떤 컨테이너든 접속할 수 있는 원활한 워크플로우를 제공합니다.

### status - 상태 확인

컨테이너의 현재 상태를 확인합니다.

```bash
dockit status
```

이 명령어는 다음 정보를 표시합니다:

- **프로젝트 설정 정보**:
  - Dockit 버전
  - 이미지 이름
  - 컨테이너 이름

- **호스트 사용자 설정**:
  - 사용자 이름
  - 사용자 UID
  - 사용자 GID
  - 작업 디렉토리

- **컨테이너 사용자 정보**:
  - 컨테이너 사용자 이름
  - 컨테이너 사용자 UID
  - 컨테이너 사용자 GID

- **컨테이너 상태** (컨테이너가 있는 경우):
  - 컨테이너 ID
  - 실행 상태
  - 생성 시간
  - 이미지 정보
  - IP 주소 (실행 중인 경우)
  - 포트 정보 (실행 중인 경우)

호스트 사용자 설정과 컨테이너 사용자 정보가 항상 구분되어 표시되므로, 권한 문제를 진단할 때 특히 유용합니다. 컨테이너가 아직 생성되지 않은 경우에도 호스트 설정은 확인할 수 있습니다.

### list - 프로젝트 목록

dockit으로 생성된 모든 프로젝트를 목록으로 표시하며, 실시간 Docker 상태 동기화 기능을 제공합니다.

```bash
dockit list
```

#### 주요 기능:

**실시간 상태 동기화**:
- 명령어 실행 시마다 각 프로젝트의 실제 Docker 상태를 확인
- 외부에서 변경된 Docker 이미지/컨테이너 상태를 자동으로 감지하여 레지스트리에 반영
- 수동으로 설정된 `error` 상태는 자동 변경에서 제외되어 보존됨

**표시 정보**:
- 프로젝트 번호
- 프로젝트 경로 (간소화된 형태)
- 현재 프로젝트 상태 (색상으로 구분)
- 이미지 이름
- 컨테이너 이름

#### 상태별 색상 표시:
- **`none`** (파란색): 초기화 후 빌드 전 상태
- **`ready`** (청록색): 이미지 빌드 완료, 실행 준비 상태
- **`error`** (빨간색): 빌드 실패 또는 오류 상태
- **`running`** (초록색): 컨테이너 실행 중
- **`stopped`** (노란색): 컨테이너 정지됨
- **`down`** (회색): 컨테이너 제거됨

#### 동기화 동작 예시:
```bash
# Docker로 직접 이미지 삭제
docker image rm my-project-image

# dockit list 실행 시 상태가 ready → none으로 자동 변경
dockit list
```

#### 경로 표시:
- 홈 디렉토리를 `~` 단축어로 표시
- 가독성을 높이기 위해 간소화된 경로 표시
- 문제가 있는 프로젝트에 경고 표시

이 기능을 통해 여러 프로젝트를 관리할 때 실제 Docker 상태와 레지스트리 정보가 항상 일치하도록 보장됩니다.

### ls - 빠른 프로젝트 목록

dockit으로 생성된 모든 프로젝트 목록 표시 (`list` 명령어의 별칭).

```bash
dockit ls
```

이것은 `list` 명령어의 편리한 단축 명령어로, 동일한 기능을 제공합니다:
- 실시간 Docker 상태 동기화
- 색상으로 구분된 상태 표시
- 프로젝트 정보 개요

적은 타이핑으로 빠른 상태 확인이 필요할 때 완벽합니다. `list` 명령어의 모든 기능을 이 별칭을 통해 사용할 수 있습니다.

### image - 이미지 관리

dockit으로 생성된 Docker 이미지를 관리하는 종합적인 기능을 제공합니다.

```bash
dockit image <명령어> [옵션]
```

#### 하위 명령어:

**1. list - 이미지 목록 보기**
```bash
dockit image list
# 또는
dockit image ls
```
- dockit으로 생성된 모든 Docker 이미지를 표 형태로 표시
- 번호, 이미지 ID, 생성일, 크기, 이미지 이름을 포함
- 이미지가 없는 경우 생성 방법 안내
- `ls`는 `list`의 편리한 단축 별칭입니다

**2. remove - 특정 이미지 제거**
```bash
dockit image remove <이미지_이름_또는_번호>
```
- 이미지 이름 또는 목록 번호로 특정 이미지 제거
- 예시:
  ```bash
  dockit image remove 1                        # 번호로 제거
  dockit image remove dockit-home-user-project # 이름으로 제거
  ```

**3. prune - 사용하지 않는 이미지 정리**
```bash
dockit image prune
```
- 어떤 컨테이너에서도 사용되지 않는 dockit 이미지들을 찾아 제거
- 제거 전 이미지 목록과 예상 절약 공간을 표시
- 안전한 확인 프롬프트 제공

**4. clean - 모든 이미지 제거**
```bash
dockit image clean
```
- 모든 dockit 이미지와 관련 컨테이너를 완전히 제거
- 매우 강력한 기능으로 되돌릴 수 없음
- 2단계 안전 확인 과정:
  1. 첫 번째 확인: 'y' 또는 'yes' 입력
  2. 두 번째 확인: 'DELETE' (대문자) 입력

#### 주요 특징:

**안전 장치**:
- dockit 이미지만 대상으로 하여 시스템 이미지 보호
- 이미지 사용 중인 컨테이너 자동 감지 및 경고
- 제거 전 상세한 정보 제공 (사용 현황, 예상 절약 공간 등)

**상세한 분석**:
- 이미지별 사용 상태 표시 (사용 중/사용 안함)
- 컨테이너 종속성 정보 제공
- 총 이미지 수, 사용 중인 이미지 수, 예상 절약 공간 계산

**자동 정리**:
- `clean` 명령어는 관련 컨테이너도 자동으로 중지하고 제거
- 각 단계별 진행 상황을 시각적으로 표시 (✓/✗/⚠️)

#### 사용 시나리오:

**정기적인 정리**:
```bash
# 사용하지 않는 이미지만 정리 (안전)
dockit image prune

# 개발 환경 완전 초기화 (주의 필요)
dockit image clean
```

**특정 이미지 관리**:
```bash
# 이미지 목록 확인
dockit image list

# 특정 이미지 제거
dockit image remove 3
```

이 기능을 통해 Docker 이미지 사용량을 효과적으로 관리하고, 시스템 자원을 최적화할 수 있습니다.

### migrate - 버전 업그레이드

Dockit을 새 버전으로 업그레이드하면서 사용자 설정을 보존합니다.

```bash
dockit migrate
```

이 명령어는 다음 작업을 수행합니다:
- 현재 설정의 백업 생성
- 새 버전 환경 초기화
- 사용자 설정을 새 버전으로 마이그레이션
- 사용자 지정 설정 보존

마이그레이션 과정은 안전하게 설계되어 있으며, 실패 시 자동 롤백 기능이 포함되어 있습니다.

### setup - 전체 환경 설정

초기화, 빌드, 시작, 접속을 한번에 실행합니다.

```bash
dockit setup
```

이 명령어는 다음 작업을 순차적으로 수행하여 간소화된 프로세스를 제공합니다:
- Docker 개발 환경 초기화 (`init` 명령어와 동일)
- Docker 이미지 빌드 (`build` 명령어와 동일)
- 컨테이너 시작 (`up` 명령어와 동일)
- 컨테이너 접속 (`connect` 명령어와 동일)

각 단계마다 진행 여부를 확인하는 프롬프트가 표시되므로, 원하는 시점에 중단할 수 있습니다. 이 명령어는 단일 명령으로 전체 환경을 설정하면서도 각 단계를 제어하고 싶은 사용자에게 이상적입니다.

### run - 자동 실행

초기화, 빌드, 시작을 자동으로 한 번에 실행합니다.

```bash
dockit run
```

이 명령어는 사용자 확인 프롬프트 없이 다음 작업을 순차적으로 수행합니다:
- Docker 개발 환경 초기화 (`init` 명령어와 동일)
- Docker 이미지 빌드 (`build` 명령어와 동일)
- 컨테이너 백그라운드에서 시작 (`up` 명령어와 동일)

`setup` 명령어가 각 단계마다 사용자 확인을 요구하는 것과 달리, `run` 명령어는 모든 작업을 자동으로 연속해서 실행합니다. 이는 스크립트나 중단 없이 모든 작업을 수행하고 싶은 상황에 이상적입니다.

### ps - 컨테이너 목록

dockit으로 생성된 모든 컨테이너(실행 중 및 정지)를 나열합니다.

```bash
dockit ps
```

이 명령어는 dockit으로 생성된 모든 컨테이너에 대해 다음 정보를 표시합니다:
- 컨테이너 ID (12자리)
- 이미지 이름
- 컨테이너 이름 (간소화된 형태로 표시)
- 생성 날짜 및 시간
- 상태 (실행 중 또는 정지됨, 색상으로 구분)
- IP 주소 (실행 중인 컨테이너의 경우)
- 노출된 포트 (실행 중인 컨테이너의 경우)

컨테이너 이름은 가독성을 높이기 위해 간소화된 형태로 표시됩니다:
- 'dockit-' 접두사가 제거됩니다
- 전체 경로 대신 의미 있는 마지막 디렉토리 이름을 표시합니다
  - 예: 'dockit-home-hgs-dockit-test-temp-b' → 'temp-b'

이 기능은 여러 개의 dockit 환경을 관리할 때 매우 유용하며, 특히 여러 프로젝트에서 생성된 컨테이너들을 한눈에 구분하고 상태를 파악할 수 있습니다.

### help - 도움말

도움말 정보를 표시합니다.

```bash
dockit help
```

## 설정 파일

Dockit은 `.dockit_project/.env` 파일에 모든 설정을 저장합니다. 이 파일은 초기화 과정에서 생성되며, 다음과 같은 정보를 포함합니다:

```
# Docker Tools Configuration File
# Docker Tools 설정 파일
# Auto-generated: [날짜]
# 자동 생성됨: [날짜]

# Container Settings
# 컨테이너 설정
IMAGE_NAME="[이미지 이름]"
CONTAINER_NAME="[컨테이너 이름]"

# User Settings
# 사용자 설정
USERNAME="[사용자 이름]"
USER_UID="[UID]"
USER_GID="[GID]"
USER_PASSWORD="[비밀번호]"
WORKDIR="[작업 디렉토리]"
```

이 파일은 필요에 따라 수동으로 편집할 수 있습니다.

## 문제 해결

### 초기화 문제

**문제**: 초기화가 실패하는 경우
**해결책**: 
- Docker가 실행 중인지 확인하세요.
- 필요한 권한이 있는지 확인하세요.
- `.dockit_project` 디렉토리를 삭제하고 다시 시도하세요.

### 컨테이너 시작 문제

**문제**: 컨테이너가 시작되지 않는 경우
**해결책**:
- 포트 충돌이 없는지 확인하세요.
- Docker 서비스가 실행 중인지 확인하세요.
- Docker 이미지가 존재하는지 확인하세요.

### 컨테이너 접속 문제

**문제**: 컨테이너에 접속할 수 없는 경우
**해결책**:
- 컨테이너가 실행 중인지 확인하세요.
- 컨테이너 이름이 올바른지 확인하세요.

### 컨테이너 사용자 이름 문제

**문제**: 설정한 사용자 이름(USERNAME)과 컨테이너 내부 사용자 이름이 다른 경우
**해결책**:
- **v1.2.0부터 자동으로 처리됩니다.** UID 충돌이 감지되면 기존 컨테이너 사용자에게 자동으로 비밀번호가 설정됩니다.
- `dockit status` 명령으로 확인할 수 있는 컨테이너 사용자 정보는 베이스 이미지에 이미 존재하는 사용자를 사용하는 경우 다를 수 있습니다.
- **중요한 것은 UID와 GID가 일치하는지 여부입니다.** 파일 시스템 권한은 이름이 아닌, UID/GID에 의해 결정됩니다.
- **sudo 접근**: 기존 사용자(예: ubuntu)에게 설정된 비밀번호로 sudo 명령을 사용할 수 있습니다.
- 파일 권한 문제가 발생하면 `dockit status`로 컨테이너 사용자의 UID/GID가 호스트 시스템의 사용자 UID/GID와 일치하는지 확인하세요.

### UID 충돌 및 비밀번호 문제

**문제**: 베이스 이미지에 이미 동일한 UID를 가진 사용자가 존재하여 비밀번호 설정이 실패하는 경우
**해결책**:
- **v1.2.0부터 자동으로 해결됩니다.** Dockerfile에서 UID 충돌을 자동 감지하고 기존 사용자에게 비밀번호를 설정합니다.
- Docker 캐싱으로 인해 변경사항이 반영되지 않는 경우 `dockit build --no-cache`를 사용하세요.
- 수동 확인: 컨테이너 내부에서 `/etc/shadow` 파일을 확인하여 사용자 계정 상태를 점검할 수 있습니다. 